import { useState, useEffect, Suspense, useRef } from "react";
import { NewFileButton } from "@/components/new-file-button";
import { ExistingFilesList } from "@/components/existing-files-list";
import { OpenOutputDirButton } from "@/components/open-output-dir-button";
import { Canvas } from "@react-three/fiber";
import { OrbitControls, useGLTF, Html } from "@react-three/drei";
import * as THREE from "three";
import {
  CheckCircle,
  XCircle,
  FileText,
  CuboidIcon as Cube,
  Sliders,
} from "lucide-react";
import { useNavigate } from "react-router-dom";
import { Button } from "@/components/ui/button";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { useGetSelectedConfigData } from "@/hooks/queries/useGetSelectedConfigData";
import { ErrorBoundary } from "react-error-boundary";
import { RotatingPrimitive } from "@/components/three-components";

// Instead of using Tauri's FS API, we use the invoke function to call our Rust command.
import { invoke } from "@tauri-apps/api/core";

/**
 * Custom hook: useGLBBlobUrl
 * Reads the GLB file at the given modelPath using our Rust command,
 * creates a Blob URL, and returns that URL.
 */
function useGLBBlobUrl(modelPath: string): string | null {
  const [blobUrl, setBlobUrl] = useState<string | null>(null);

  useEffect(() => {
    // Reset blobUrl whenever modelPath changes.
    setBlobUrl(null);
    let revokeUrl: string | null = null;

    async function loadFile() {
      try {
        // Call the Rust command "open_file" to read the file as binary data.
        // Your Rust command should return a Vec<u8>, which is deserialized as an array of numbers.
        const fileData: number[] = await invoke("open_file", {
          path: modelPath,
        });
        // Convert the returned number array into a Uint8Array.
        const uint8Array = new Uint8Array(fileData);
        // Create a Blob from the binary data with the appropriate MIME type.
        const blob = new Blob([uint8Array], { type: "model/gltf-binary" });
        const url = URL.createObjectURL(blob);
        revokeUrl = url;
        setBlobUrl(url);
      } catch (err) {
        console.error("Error reading GLB file via Rust command:", err);
        setBlobUrl(null);
      }
    }
    loadFile();

    // Cleanup: revoke the Blob URL when the component unmounts or modelPath changes.
    return () => {
      if (revokeUrl) {
        URL.revokeObjectURL(revokeUrl);
      }
    };
  }, [modelPath]);

  return blobUrl;
}

/**
 * ModelInner loads the GLTF model using the Blob URL generated by useGLBBlobUrl.
 */
function ModelInner({ modelPath }: { modelPath: string }) {
  // Get the Blob URL from our custom hook.
  const blobUrl = useGLBBlobUrl(modelPath);

  // Until the blob URL is available, do not render anything.
  if (!blobUrl) return null;

  // Load the GLTF model from the Blob URL.
  const { scene } = useGLTF(blobUrl);
  return (
    <RotatingPrimitive
      object={scene}
      scale={[1, 1, 1]}
      position={[0, 0, 0]}
      rotationSpeed={0.005}
    />
  );
}

/**
 * ModelWrapper handles loading state, errors, and passes the modelPath
 * (from planeData) to ModelInner.
 */
function ModelWrapper() {
  const { data: planeData, isLoading, error } = useGetSelectedConfigData();

  if (isLoading) {
    // Since ModelWrapper is rendered inside the Canvas, using <Html> is acceptable.
    return <Html center>Loading...</Html>;
  }
  if (error || !planeData || !planeData.modelPath?.includes(".glb")) {
    return (
      <Html center>
        <div className="text-nowrap">
          {error ? `Select a Plane` : "Model file not found or invalid"}
        </div>
      </Html>
    );
  }

  return (
    <ErrorBoundary
      fallback={
        <Html center>
          <Card>
            <CardContent>Error loading Plane data</CardContent>
          </Card>
        </Html>
      }
    >
      <Suspense
        fallback={
          <Html center>
            <Card>
              <CardContent>Loading Plane data...</CardContent>
            </Card>
          </Html>
        }
      >
        <ModelInner key={planeData.modelPath} modelPath={planeData.modelPath} />
      </Suspense>
    </ErrorBoundary>
  );
}

/**
 * ModelViewer wraps the model content in a Canvas and resets OrbitControls when needed.
 */
function ModelViewer() {
  const { data: planeData } = useGetSelectedConfigData();
  const orbitRef = useRef<any>(null);

  // Reset OrbitControls whenever the modelPath changes.
  useEffect(() => {
    if (orbitRef.current) {
      orbitRef.current.reset();
    }
  }, [planeData?.modelPath]);

  return (
    <div className="h-full w-full">
      <Canvas camera={{ position: [0, 5, 12], fov: 50 }}>
        {/* Lighting setup */}
        <ambientLight intensity={1.2} />
        <directionalLight intensity={1} position={[10, 10, 10]} castShadow />
        <hemisphereLight
          color={0xffffff}
          groundColor={0x444444}
          intensity={0.6}
        />

        {/* Render the model via ModelWrapper */}
        <ModelWrapper />

        {/* OrbitControls */}
        <OrbitControls
          ref={orbitRef}
          enablePan={false}
          minDistance={60}
          maxDistance={200}
          zoomSpeed={0.5}
        />
      </Canvas>
    </div>
  );
}

/**
 * ModelPreview card that displays the model.
 */
function ModelPreview() {
  return (
    <Card className="h-full flex flex-col">
      <CardHeader>
        <CardTitle className="text-2xl font-bold flex items-center">
          <Cube className="w-6 h-6 mr-2" />
          Plane Model
        </CardTitle>
      </CardHeader>
      <CardContent className="flex-1 min-h-0">
        <div className="h-full w-full">
          <ModelViewer />
        </div>
      </CardContent>
    </Card>
  );
}

/**
 * FileManagement component handles file-related UI actions.
 */
function FileManagement() {
  const [isCreatingNewFile, setIsCreatingNewFile] = useState(false);

  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle className="text-2xl font-bold flex items-center">
          <FileText className="w-6 h-6 mr-2" />
          Plane Configs
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        <div className="flex justify-between items-center">
          <NewFileButton onNewFile={() => setIsCreatingNewFile(true)} />
          <OpenOutputDirButton />
        </div>
        <ExistingFilesList
          isCreatingNewFile={isCreatingNewFile}
          onNewFileCreated={() => setIsCreatingNewFile(false)}
        />
      </CardContent>
    </Card>
  );
}

/**
 * Interface for a switch item.
 */
interface SwitchItem {
  name: string;
  mesh: THREE.Mesh;
  isConfigured: boolean;
  switchType: string;
}

/**
 * The outer SwitchInfo component uses our custom hook to get the Blob URL.
 * It renders a fallback until the URL is ready, then renders SwitchInfoLoader.
 */
function SwitchInfo({ planeData }: { planeData: any }) {
  const blobUrl = useGLBBlobUrl(planeData.modelPath);

  if (!blobUrl) {
    return <div style={{ textAlign: "center" }}>Loading plane data...</div>;
  }
  return <SwitchInfoLoader blobUrl={blobUrl} planeData={planeData} />;
}

/**
 * SwitchInfoLoader uses the provided Blob URL to load the GLTF model and
 * extract switch meshes.
 */
function SwitchInfoLoader({
  blobUrl,
  planeData,
}: {
  blobUrl: string;
  planeData: any;
}) {
  const [modelError, setModelError] = useState<string | null>(null);
  const [switches, setSwitches] = useState<SwitchItem[]>([]);

  const gltf = useGLTF(blobUrl, undefined, undefined, (error) => {
    console.error("GLTF loading error in SwitchInfoLoader:", error);
    setModelError(error.message);
  });

  useEffect(() => {
    if (gltf?.scene && planeData) {
      const switchTags = ["-Dial", "-Button", "-Lever"];
      const foundSwitches: SwitchItem[] = [];
      gltf.scene.traverse((child) => {
        if (child instanceof THREE.Mesh) {
          const tagFound = switchTags.find((tag) => child.name.includes(tag));
          if (tagFound) {
            const baseName = child.name.split(tagFound)[0];
            const typeValue = tagFound.replace("-", "").toLowerCase();
            const isConfigured = Object.keys(planeData.switches || {}).includes(
              baseName
            );
            foundSwitches.push({
              name: baseName,
              mesh: child,
              isConfigured,
              switchType: typeValue,
            });
          }
        }
      });
      setSwitches(foundSwitches);
    }
  }, [gltf, planeData]);

  const totalSwitches = switches.length;
  const configuredSwitches = switches.filter((s) => s.isConfigured).length;

  return (
    <div className="space-y-4">
      <Separator />
      <div className="flex items-center justify-between">
        <span className="font-semibold">Switches:</span>
        <div className="flex items-center">
          {totalSwitches > 0 ? (
            configuredSwitches === totalSwitches ? (
              <div className="flex items-center text-green-500">
                <CheckCircle className="w-5 h-5 mr-1" />
                <span>
                  Configured ({configuredSwitches} of {totalSwitches})
                </span>
              </div>
            ) : (
              <div className="flex items-center text-red-500">
                <XCircle className="w-5 h-5 mr-1" />
                <span>
                  Configured ({configuredSwitches} of {totalSwitches})
                </span>
              </div>
            )
          ) : (
            <div className="flex items-center text-red-500">
              <XCircle className="w-5 h-5 mr-1" />
              <span>No switches found</span>
            </div>
          )}
        </div>
      </div>
      <div className="flex items-center justify-between">
        <span className="font-semibold">Model Path:</span>
        <span className="italic">{planeData.modelPath}</span>
      </div>
      <Separator />
    </div>
  );
}

/**
 * InfoPane displays plane configuration details and uses SwitchInfo.
 */
function InfoPane() {
  const { data: planeData, isLoading, error } = useGetSelectedConfigData();
  const navigate = useNavigate();

  const handleConfigureSwitches = () => {
    navigate("/switchEditor");
  };

  if (isLoading) {
    return (
      <Card className="flex items-center justify-center h-full">
        <CardContent>Loading...</CardContent>
      </Card>
    );
  }
  if (error) {
    return (
      <Card className="flex items-center justify-center h-full">
        <CardContent>Select a Plane</CardContent>
      </Card>
    );
  }
  if (!planeData) {
    return (
      <Card className="h-full">
        <CardContent>No data available, please create a plane</CardContent>
      </Card>
    );
  }

  return (
    <Card className="h-full">
      <CardHeader>
        <CardTitle className="text-2xl font-bold text-center">
          {planeData.planeName}
        </CardTitle>
      </CardHeader>
      <CardContent className="flex flex-col h-[calc(100%-5rem)] justify-between">
        <Suspense fallback={<div>Loading switch info...</div>}>
          <SwitchInfo planeData={planeData} />
        </Suspense>
        <Button
          onClick={handleConfigureSwitches}
          className="w-full mt-4"
          size="lg"
        >
          <Sliders className="w-5 h-5 mr-2" />
          Configure Switches
        </Button>
      </CardContent>
    </Card>
  );
}

/**
 * MainScreen component aggregates FileManagement, ModelPreview, and InfoPane.
 */
export function MainScreen() {
  return (
    <div className="w-full min-h-screen p-4 flex flex-col">
      <div className="flex flex-1 gap-6 min-h-0">
        <div className="w-1/3 flex flex-col">
          <FileManagement />
        </div>
        <div className="w-2/3 flex flex-col gap-6">
          <div className="flex-1 min-h-0">
            <ModelPreview />
          </div>
          <div className="h-1/3 max-h-64">
            <InfoPane />
          </div>
        </div>
      </div>
    </div>
  );
}
